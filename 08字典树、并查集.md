## 08字典树、并查集

## 字典树

[leetcode 208 实现Trie（前缀树）](https://leetcode.cn/problems/implement-trie-prefix-tree/)

```C++
class Trie {
public:    
  /** Initialize your data structure here. */    
  Trie() {         
    root = new Node();    
  }    
  
  /** Inserts a word into the trie. */    
  void insert(string word) {         
    find(word, true, true);     
  }    
  
  /** Returns if the word is in the trie. */    
  bool search(string word) {         
    return find(word, true, false);     
  }    
  
  /** Returns if there is any word in the trie that starts with the given prefix. */
  bool startsWith(string prefix) {         
    return find(prefix, false, false);    
  }
private:    
  struct Node {        
    int count;        
    unordered_map<char, Node*> child;        
    Node(): count(0) {}    
  };    
  Node* root;    
  
  bool find(const string& s, bool exact_match, bool insert_if_not_exist) {        
    Node* curr = root;        
    for (char c : s) {            
      if (curr->child.find(c) == curr->child.end()) {                
        if (!insert_if_not_exist) return false;                
        curr->child[c] = new Node();            
      }            
      curr = curr->child[c];        
    }        
    if (insert_if_not_exist) curr->count++;        
    return exact_match ? curr->count > 0 : true;    
  }
};
```



[leetcode 212 单词搜索2](https://leetcode.cn/problems/word-search-ii/)

```C++
class Solution {
public:
  vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    //建立Trie
    root = new Node();
    for(const string& word: words) insert(word);

    m = board.size(), n = board[0].size();
    visit = vector<vector<bool>>(m, vector<bool>(n, false));
    for(int i = 0; i < m; ++i)
      for(int j = 0; j < n; ++j) {
        visit[i][j] = true;
        dfs(board, i, j, root);
        visit[i][j] = false;
      }

    return vector<string>(ans.begin(), ans.end());
  }

private:
  struct Node {
    int count;
    unordered_map<char, Node*> child;
    Node(): count(0) {}
  };
  vector<int> dx = {-1, 0, 0, 1};
  vector<int> dy = {0, -1, 1, 0};
  Node* root;
  int m, n;
  vector<vector<bool>> visit;
  string str;
  unordered_set<string> ans;

  void dfs(vector<vector<char>>& board, int x, int y, Node* curr) {
    char ch = board[x][y];
    if(curr->child.find(ch) == curr->child.end())   return;
    Node* next = curr->child[ch];

    str.push_back(ch);
    if(next->count > 0) ans.insert(str);

    if(next->child.empty()) {
      curr->child.erase(ch);
      delete next;
    } else {
      for(int i = 0; i < 4; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if(nx < 0 || ny <0 || nx >= m || ny >= n) continue;
        if(visit[nx][ny]) continue;
        visit[nx][ny] = true;
        dfs(board, nx, ny, next); 
        visit[nx][ny] = false;
      }
    }
    str.pop_back();
  }

  void insert(const string& s) {
    Node* curr = root;
    for(char c : s) {
      if(curr->child.find(c) == curr->child.end()) {
        curr->child[c] = new Node();
      }
      curr = curr->child[c];
    }
    curr->count++;
  }
};
```



## 并查集

实现：

```C++
class DisjointSet {
public:
	DisjointSet(int n) {
    fa = vector<int>(n, 0);
    for(int i = 0; i < n; ++i)	fa[i] = i;
  }  
  
  int find(int x) {
    if(x == fa[x])	return x;
    return fa[x] = find(fa[x]);//路径压缩
  }
  
  void unionSet(int x, int y) {
    x = find(x), y = find(y);
    if(x != y)	fa[x] = y;
  }
  
private:
  vector<int> fa;
}
```

[leetcode 547 省份数量](https://leetcode.cn/problems/number-of-provinces/)

```C++
class Solution {
public:
  int findCircleNum(vector<vector<int>>& isConnected) {
    int n = isConnected.size();
    //makeSet
    fa = vector<int>(n, 0);
    for(int i = 0; i < n; ++i) fa[i] = i;

    //unionset
    for(int i = 0; i < n; ++i)
      for(int j = 0; j < n; ++j) {
        if(isConnected[i][j])   unionset(i, j);
      }
    int res = 0;
    for(int i = 0; i < n; ++i)
      if(find(i) == i) ++res;
    return res;
  }

private:
  vector<int> fa;

  void unionset(int x, int y) {
    x = find(x), y = find(y);
    if(x != y) fa[x] = y;
  }

  int find(int x) {
    if(fa[x] == x)    return x;
    return fa[x] = find(fa[x]);
  }
};
```

[leetcode 130 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

```C++
class Solution {
public:
  void solve(vector<vector<char>>& board) {
    m = board.size(), n = board[0].size();
    fa = vector<int> (n * m + 1, 0);
    for(int i = 0; i < n * m + 1; ++i) fa[i] = i;

    int outside = m * n;
    for(int i = 0; i < m; ++i)
      for(int j = 0; j < n; ++j) {
        if(board[i][j] == 'X')   continue;
        for(int k = 0; k < 4; ++k) {
          int ni = i + dx[k];
          int nj = j + dy[k];
          if(ni < 0 || ni >= m || nj < 0 || nj >= n) {
            unionSet(nums(i, j), outside);
          } else {
            if(board[ni][nj] == 'O') 
              unionSet(nums(i, j), nums(ni, nj));
          }
        }
      }

    outside = find(outside);
    for(int i = 0; i < m; ++i)
      for(int j = 0; j < n; ++j) 
        if(board[i][j] == 'O' && find(nums(i, j)) != outside)
          board[i][j] = 'X';
  }

private:
  const vector<int> dx = {-1, 0, 0, 1};
  const vector<int> dy = {0, -1, 1, 0};
  int m, n;
  vector<int> fa;     

  int find(int x) {
    if(fa[x] == x)  return x;
    return fa[x] = find(fa[x]);
  }

  void unionSet(int x, int y) {
    x = find(x), y = find(y);
    if(x != y) fa[x] = y;
  }

  int nums(int i, int j) {
    return i * n + j;
  }
};
```

